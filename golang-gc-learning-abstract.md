# Golang GC学习摘要

# 标记清除（Mark-Sweep）

1. 标记阶段 - 从跟对象出发查找并标记堆中所有存活的对象
2. 清除阶段 - 遍历堆中的所有对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表

# 三色抽象

1. 白色对象 - 潜在的垃圾，其内存可能会被垃圾收集器回收
2. 黑色对象 - 活跃的对象，包括不存在任何指向白色对象的指针以及从跟对象可达的对象
3. 灰色对象 - 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象

# 三色标记垃圾收集器

## **三色标记清除算法**

1. 将根对象标记为灰色
2. 从灰色对象的集合中，选择一个灰色对象，并将其标记为黑色
3. 将该黑色对象指向的所有对象都标记为灰色，保证其和被其引用的对象都不会被回收
4. 重复上述两个步骤直到对象图中不存在灰色对象

**NOTE:**

该算法需要STW（Stop-The-World），不可以并发或者增量执行

# 屏障技术（Barrier）

## 强弱三色不变性

[Golang垃圾回收简明教程2--强弱三色不变式](https://zhuanlan.zhihu.com/p/340455930)

### **三色不变性（Tri-color invariant）**

- 弱三色不变性 - 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象
- 强三色不变性 - 黑色对象指向的白色对象，其必须（至少）包含一条从灰色对象的可达路径

## Dijkstra**插入写屏障：**

[Golang垃圾回收简明教程3--插入删除写屏障机制](https://zhuanlan.zhihu.com/p/340832838)

```bash
添加下游对象(当前下游对象slot, 新下游对象ptr):
    标记灰色(新下游对象ptr)
    *当前下游对象slot = 新下游对象ptr
```

> 插入屏障是一个很耗费性能的行为，而栈需要更高的性能要求，因此，插入屏障技术只运用在堆内存空间里，不会运用到栈里。

## Yuasa**删除写屏障**

```bash
添加下游对象(当前下游对象slot, 新下游对象ptr):
    if (当前下游对象slot是灰色 || 当前下游对象slot是白色) {
        // slot为删除对象，标记为灰色
        标记灰色(当前下游对象slot是灰色)
    } 
    *当前下游对象slot = 新下游对象ptr
// 场景1
A.添加下游对象(B, nil)
// 场景2
A.添加下游对象(B, C)
```

> 回收精度低，一个对象即使被删除了最后一个指向它的指针，也依然可以活一轮GC，在下一轮GC中才被清除。

# 引用

1. [https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/)
2. [Golang垃圾回收简明教程2--强弱三色不变式](https://zhuanlan.zhihu.com/p/340455930)
3. [Golang垃圾回收简明教程3--插入删除写屏障机制](https://zhuanlan.zhihu.com/p/340832838)